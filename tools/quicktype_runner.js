/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
const fs = require('fs');
const path = require('path');
const {
  InputData,
  JSONSchema,
  JSONSchemaInput,
  JSONSchemaStore,
  TypeScriptTargetLanguage,
  parseJSON,
  quicktype,
} = require('quicktype-core');

/**
 * This file is pure JavaScript because Bazel only support compiling to ES5, while quicktype is
 * ES2015. This results in an incompatible call to `super()` in the FetchingJSONSchemaStore
 * class as it tries to call JSONSchemaStore's constructor in ES5.
 * TODO: move this file to typescript when Bazel supports ES2015 output.
 *
 * This file wraps around quicktype and can do one of two things;
 *
 * `node quicktype_runner.js <in_path> <out_path>`
 *   Reads the in path and outputs the TS file at the out_path.
 *
 * Using `-` as the out_path will output on STDOUT instead of a file.
 */

// Header to add to all files.
const header = `
// THIS FILE IS AUTOMATICALLY GENERATED. TO UPDATE THIS FILE YOU NEED TO CHANGE THE
// CORRESPONDING JSON SCHEMA FILE, THEN RUN devkit-admin build (or bazel build ...).

// tslint:disable:no-global-tslint-disable
// tslint:disable

`;

// Footer to add to all files.
const footer = ``;

/**
 * The simplest Node JSONSchemaStore implementation we can build which supports our custom protocol.
 * Supports reading from ng-cli addresses, valid URLs and files (absolute).
 */
class FetchingJSONSchemaStore extends JSONSchemaStore {
  /**
   * @description Sets the value of `this._inPath`, which is a property of the object.
   * 
   * @param { string } inPath - path to the code's source file.
   */
  constructor(inPath) {
    super();
    this._inPath = inPath;
  }

  /**
   * @description Retrieves the content of a URL or file and returns it as JSON schema
   * parsed from a string. It handles different types of URLs and files, resolving
   * relative paths to their absolute versions, and reads the contents of files
   * synchronously using `fs`.
   * 
   * @param { string } address - path to a file or URL that can be read using the `fs`
   * module or fetched using the `node-fetch` library, and is used to generate high-quality
   * documentation for the code.
   * 
   * @returns { Undefined } a JSON schema representation of the content at the specified
   * address.
   * 
   * 	* `content`: The contents of the fetched file, represented as a string. If the
   * file is null, then this property is also null.
   * 	* `address`: The original URL or path that was fetched, passed as an argument to
   * the function.
   * 	* `path`: The resolved absolute path of the fetched file, if it was relative to
   * the `_inPath` property of the module. If the file does not exist at the given path,
   * then this property is null.
   * 	* `jsonSchema`: The JSON schema for the content, passed as an argument to the
   * function. This property is undefined if the content is null.
   */
  async fetch(address) {
    const URL = require("url");
    const url = URL.parse(address);
    let content = null;
    if (url.protocol === 'ng-cli:') {
      let filePath = path.join(__dirname, '../packages/angular/cli', url.hostname, url.path);
      content = fs.readFileSync(filePath, 'utf-8').trim();
    } else if (url.hostname) {
      try {
        const fetch = require("node-fetch");
        const response = await fetch(address);
        content = response.text();
      } catch (e) {
        content = null;
      }
    }

    if (content === null && !path.isAbsolute(address)) {
      const resolvedPath = path.join(path.dirname(this._inPath), address);

      // Check relative to inPath
      if (fs.existsSync(resolvedPath)) {
        content = fs.readFileSync(resolvedPath, 'utf-8');
      }
    }

    if (content === null && fs.existsSync(address)) {
      content = fs.readFileSync(address, 'utf-8').trim();
    }

    if (content == null) {
      return undefined;
    }

    return parseJSON(content, "JSON Schema", address);
  }
}


/**
 * @description Takes two parameters `inPath` and `outPath`, generates documentation
 * for code using the `generate` function, and outputs the generated documentation
 * to `outPath`.
 * 
 * @param { string } inPath - path to the code files that need to be documented.
 * 
 * @param { string } outPath - destination path where the generated documentation
 * should be written to, and it can be set to `-` to console.log the content directly
 * or any other path for file writing.
 */
async function main(inPath, outPath) {
  const content = await generate(inPath);

  if (outPath === '-') {
    console.log(content);
    process.exit(0);
  }

  const buildWorkspaceDirectory = process.env['BUILD_WORKSPACE_DIRECTORY'] || '.';
  outPath = path.resolve(buildWorkspaceDirectory, outPath);
  fs.writeFileSync(outPath, content, 'utf-8');
}


/**
 * @description Takes a path as input and returns generated documentation for given
 * code using QuickType API.
 * 
 * @param { array } inPath - path to a JSON schema file that is used to generate the
 * API documentation with the QuickType API.
 * 
 * @returns { string } a document describing how to use an API, with headers, footers,
 * and JSON schema definitions generated based on the provided input data.
 */
async function generate(inPath) {
  // Best description of how to use the API was found at
  //   https://blog.quicktype.io/customizing-quicktype/
  const inputData = new InputData();
  const source = { name: 'Schema', schema: fs.readFileSync(inPath, 'utf-8') };

  await inputData.addSource('schema', source, () => {
    return new JSONSchemaInput(new FetchingJSONSchemaStore(inPath));
  });

  const lang = new TypeScriptTargetLanguage();

  const { lines } = await quicktype({
    lang,
    inputData,
    alphabetizeProperties: true,
    rendererOptions: {
      'just-types': 'true',
      'explicit-unions': 'true',
    },
  });

  return header + lines.join('\n') + footer;
}

if (require.main === module) {
  // Parse arguments and run main().
  const argv = process.argv.slice(2);
  if (argv.length < 2 || argv.length > 3) {
    console.error('Must include 2 or 3 arguments.');
    process.exit(1);
  }

  main(argv[0], argv[1])
    .then(() => process.exit(0))
    .catch(err => {
      console.error('An error happened:');
      console.error(err);
      process.exit(127);
    });
}

exports.generate = generate;
